"""
Ticket entity for Jira Cleanup.

This module defines the Ticket domain entity, which represents a Jira ticket
with its essential properties and domain behaviors.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any


@dataclass
class User:
    """Value object representing a user associated with a ticket."""
    
    display_name: str
    username: Optional[str] = None
    account_id: Optional[str] = None
    
    def __str__(self) -> str:
        """String representation of the user."""
        return self.display_name


@dataclass
class Comment:
    """Value object representing a comment on a ticket."""
    
    id: str
    body: str
    author: User
    created_date: datetime
    updated_date: datetime
    
    @property
    def is_system_comment(self) -> bool:
        """Check if this comment was generated by the system."""
        system_markers = [
            '[AUTOMATED QUIESCENCE ASSESSMENT]',
            '[Quiescent Ticket System]',
            '[JIRA GOVERNANCE SYSTEM]'
        ]
        return any(marker in self.body for marker in system_markers)


@dataclass
class ChangeLogItem:
    """Value object representing a change to a ticket field."""
    
    field: str
    from_value: str
    to_value: str
    author: User
    date: datetime


@dataclass
class Ticket:
    """
    Domain entity representing a Jira ticket.
    
    This class encapsulates the core properties and behaviors of a ticket,
    independent of any specific data source or framework.
    """
    
    key: str
    summary: str
    status: str
    issue_type: str
    created_date: datetime
    updated_date: datetime
    description: str = ""
    project_key: str = ""
    workflow_status: str = "Unknown"
    assignee: Optional[User] = None
    reporter: Optional[User] = None
    creator: Optional[User] = None
    comments: List[Comment] = field(default_factory=list)
    changelog: List[ChangeLogItem] = field(default_factory=list) 
    labels: List[str] = field(default_factory=list)
    components: List[str] = field(default_factory=list)
    watchers: List[User] = field(default_factory=list)
    
    @property
    def has_system_comment(self) -> bool:
        """Check if the ticket has any system-generated comments."""
        return any(comment.is_system_comment for comment in self.comments)
    
    @property
    def days_since_update(self) -> int:
        """Calculate days since the last update to this ticket."""
        now = datetime.now().replace(tzinfo=self.updated_date.tzinfo)
        return (now - self.updated_date).days
    
    @property
    def days_since_creation(self) -> int:
        """Calculate days since this ticket was created."""
        now = datetime.now().replace(tzinfo=self.created_date.tzinfo)
        return (now - self.created_date).days
    
    def is_closed(self) -> bool:
        """Check if the ticket is in a closed status."""
        closed_statuses = ['Closed', 'Done', 'Resolved', 'Completed']
        return self.status in closed_statuses
    
    def is_stale(self, threshold_days: int = 14) -> bool:
        """
        Check if the ticket is stale based on update threshold.
        
        Args:
            threshold_days: Number of days after which a ticket is considered stale
            
        Returns:
            True if the ticket hasn't been updated in threshold_days, False otherwise
        """
        return self.days_since_update >= threshold_days
    
    def has_recent_activity(self, days: int = 7) -> bool:
        """
        Check if the ticket has had any activity in the last N days.
        
        Args:
            days: Number of days to check for activity
            
        Returns:
            True if there's been activity in the last N days, False otherwise
        """
        now = datetime.now().replace(tzinfo=self.updated_date.tzinfo)
        
        # Check for recent comments
        for comment in self.comments:
            if (now - comment.created_date).days <= days:
                return True
        
        # Check for recent changelog entries
        for change in self.changelog:
            if (now - change.date).days <= days:
                return True
        
        return False
    
    def is_assigned(self) -> bool:
        """Check if the ticket is assigned to someone."""
        return self.assignee is not None
    
    def is_quiescent(self, stale_threshold_days: int = 14) -> bool:
        """
        Check if the ticket appears to be quiescent based on domain rules.
        
        A ticket is considered quiescent if:
        1. It's not in a closed status
        2. It's stale (hasn't been updated recently)
        3. It has no recent activity
        
        Args:
            stale_threshold_days: Days after which a ticket is considered stale
            
        Returns:
            True if the ticket appears to be quiescent, False otherwise
        """
        # Not quiescent if closed
        if self.is_closed():
            return False
        
        # Not quiescent if it has recent activity
        if self.has_recent_activity():
            return False
        
        # Quiescent if it's stale
        return self.is_stale(stale_threshold_days)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Ticket':
        """
        Create a Ticket instance from a dictionary of data.
        
        This is a factory method to create a Ticket from raw data,
        which might come from different sources.
        
        Args:
            data: Dictionary with ticket data
            
        Returns:
            A new Ticket instance
        """
        # Handle basic properties
        key = data.get('key', '')
        summary = data.get('summary', '')
        status = data.get('status', '')
        issue_type = data.get('issue_type', '')
        description = data.get('description', '')
        project_key = data.get('project', '')
        workflow_status = data.get('workflow', 'Unknown')
        
        # Parse dates
        created_date = _parse_date(data.get('created_date', None))
        updated_date = _parse_date(data.get('updated_date', None))
        
        # Parse users
        user_data = data.get('users', {})
        assignee = _create_user(user_data.get('assignee')) if 'assignee' in user_data else None
        reporter = _create_user(user_data.get('reporter')) if 'reporter' in user_data else None
        creator = _create_user(user_data.get('creator')) if 'creator' in user_data else None
        
        # Parse comments
        comments = []
        for comment_data in data.get('comments', []):
            comment = Comment(
                id=comment_data.get('id', ''),
                body=comment_data.get('body', ''),
                author=_create_user(comment_data.get('author', '')),
                created_date=_parse_date(comment_data.get('created', None)),
                updated_date=_parse_date(comment_data.get('updated', None))
            )
            comments.append(comment)
        
        # Parse changelog
        changelog = []
        for change_data in data.get('changelog', []):
            change = ChangeLogItem(
                field=change_data.get('field', ''),
                from_value=change_data.get('from_value', ''),
                to_value=change_data.get('to_value', ''),
                author=_create_user(change_data.get('author', '')),
                date=_parse_date(change_data.get('date', None))
            )
            changelog.append(change)
        
        # Parse simple lists
        labels = data.get('labels', [])
        components = data.get('components', [])
        
        # Parse watchers
        watchers = []
        for watcher_name in data.get('watchers', []):
            watchers.append(_create_user(watcher_name))
        
        return cls(
            key=key,
            summary=summary,
            status=status,
            issue_type=issue_type,
            description=description,
            project_key=project_key,
            workflow_status=workflow_status,
            created_date=created_date,
            updated_date=updated_date,
            assignee=assignee,
            reporter=reporter,
            creator=creator,
            comments=comments,
            changelog=changelog,
            labels=labels,
            components=components,
            watchers=watchers
        )


def _parse_date(date_str: Optional[str]) -> datetime:
    """
    Parse a date string to a datetime object.
    
    Args:
        date_str: Date string in Jira format
        
    Returns:
        Parsed datetime object, or current time if parsing fails
    """
    if not date_str:
        return datetime.now()
        
    try:
        # Try ISO format first (most common in Jira API)
        return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
    except (ValueError, TypeError):
        try:
            # Try common Jira date format
            from datetime import timezone
            return datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%S.%f%z")
        except (ValueError, TypeError):
            # Return current time as fallback
            return datetime.now()


def _create_user(user_data: Any) -> User:
    """
    Create a User object from various user data formats.
    
    Args:
        user_data: User data in various formats
        
    Returns:
        User object
    """
    if isinstance(user_data, dict):
        return User(
            display_name=user_data.get('displayName', user_data.get('name', 'Unknown')),
            username=user_data.get('name'),
            account_id=user_data.get('accountId')
        )
    elif isinstance(user_data, str):
        return User(display_name=user_data)
    else:
        return User(display_name='Unknown')
